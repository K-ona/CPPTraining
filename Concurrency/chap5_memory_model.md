# 内存模型和原子操作

- C++ 内存模型
- 原子类型
- 如何使用原子类型
- 使用原子操作同步线程

C++标准中有一个重要特性常被开发者所忽略，就是**多线程(感知)内存模型**，内存模型定义了基本部件应该如何工作。那为什么大多数开发者都没有注意到呢？当使用互斥量保护数据和条件变量，或者信号时，对于互斥量*为什么*能起到这样作用，大多数人并不会关心。只有试图去“接触硬件”，才能详尽的了解到内存模型是如何作用的。

==C++是系统级别的编程语言，标准委员会的目标是不需要比C++还要底层的高级语言。== C++应该向程序员提供足够的灵活性，无障碍的去做他们想要做的事情。需要时，也可以“接触硬件”。原子类型和原子操作就可以“接触硬件”，并提供底层同步操作，通常会将指令数缩减到1~2个CPU周期。

## 5.1 内存模型

内存模型一方面是内存布局，另一方面是并发

### 5.1.1 对象和内存位置

C++程序中数据都是由对象构成，对象仅仅是对C++数据构建块的声明，C++标准定义类对象为 ==“存储区域”== ，但对象还是可以将自己的特性赋予其他对象。

这里有四个需要牢记的原则：

1. 每个变量都是对象
2. 每个对象至少占有一个内存位置。
3. 基本类型都有确定的内存位置(无论类型大小如何，即使他们是相邻的，或是数组的一部分)。
4. 相邻位域是相同内存中的一部分。

==这些在并发中有什么作用？==

### 5.1.2 对象、内存位置和并发

这部分对于C++的多线程来说至关重要。当两个线程访问不同的内存位置时，不会存在任何问题，当两个线程访问同一个内存位置就要小心了。如果线程不更新数据，只读数据不需要保护或同步。当线程对内存位置上的数据进行修改，就可能会产生条件竞争。
