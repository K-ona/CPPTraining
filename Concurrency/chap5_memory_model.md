# 内存模型和原子操作

- C++ 内存模型
- 原子类型
- 如何使用原子类型
- 使用原子操作同步线程

C++标准中有一个重要特性常被开发者所忽略，就是**多线程(感知)内存模型**，内存模型定义了基本部件应该如何工作。那为什么大多数开发者都没有注意到呢？当使用互斥量保护数据和条件变量，或者信号时，对于互斥量*为什么*能起到这样作用，大多数人并不会关心。只有试图去“接触硬件”，才能详尽的了解到内存模型是如何作用的。

==C++是系统级别的编程语言，标准委员会的目标是不需要比C++还要底层的高级语言。== C++应该向程序员提供足够的灵活性，无障碍的去做他们想要做的事情。需要时，也可以“接触硬件”。原子类型和原子操作就可以“接触硬件”，并提供底层同步操作，通常会将指令数缩减到1~2个CPU周期。

## 5.1 内存模型

内存模型一方面是内存布局，另一方面是并发

### 5.1.1 对象和内存位置

C++程序中数据都是由对象构成，对象仅仅是对C++数据构建块的声明，C++标准定义类对象为 ==“存储区域”== ，但对象还是可以将自己的特性赋予其他对象。

这里有四个需要牢记的原则：

1. 每个变量都是对象
2. 每个对象至少占有一个内存位置。
3. 基本类型都有确定的内存位置(无论类型大小如何，即使他们是相邻的，或是数组的一部分)。
4. 相邻位域是相同内存中的一部分。

==这些在并发中有什么作用？==

### 5.1.2 对象、内存位置和并发

这部分对于C++的多线程来说至关重要。当两个线程访问不同的内存位置时，不会存在任何问题，当两个线程访问同一个内存位置就要小心了。如果线程不更新数据，只读数据不需要保护或同步。当线程对内存位置上的数据进行修改，就可能会产生条件竞争。

为了避免条件竞争，线程就要以一定的顺序执行。第一种方式，使用互斥量来确定访问的顺序。当同一互斥量在两个线程同时访问前锁住，那么在同一时间内就只有一个线程能够访问对应的内存位置。另一种是使用原子操作决定两个线程的访问顺序，当多个线程访问同一个内存地址时，对每个访问者都需要设定顺序。

如果不规定对同一内存地址访问的顺序，那么访问就不是原子的。当两个线程都是“写入者”时，就会产生数据竞争和未定义行为。

未定义的行为是C++中的黑洞，当程序对同一内存地址中的数据访问存在竞争，可以使用原子操作来避免未定义行为。当然，这不会影响竞争的产生——原子操作并没有指定访问顺序——而原子操作会把程序拉回到定义行为的区域内。

### 5.1.3 修改顺序

如果对象不是原子类型(将在5.2节详述)，必须确保有足够的同步操作，确定线程都遵守了修改顺序。当不同线程在不同序列中访问同一个值时，可能就会遇到数据竞争或未定义行为(详见5.1.2节)。如果使用原子操作，编译器就有责任去做同步。

因为当线程按修改顺序访问一个特殊的输入，所以投机执行是不允许的。 **之后的读操作必须由线程返回新值，并且之后的写操作必须发生在修改顺序之后。** 虽然，所有线程都需要遵守程序中每个非独立对象的修改顺序，但==没有必要遵守在独立对象上的操作顺序==。在5.3.3节中会有更多关于不同线程间操作顺序的内容。所以，什么是原子操作？怎样规定顺序？

## 5.2 原子操作和原子类型

原子操作是个不可分割的操作。系统的所有线程中，不可能观察到原子操作完成了一半。如果读取对象的加载操作是原子的，那么这个对象的所有修改操作也是原子的，所以加载操作得到的值要么是对象的初始值，要么是某次修改操作存入的值。

另一方面，非原子操作可能会被另一个线程观察到只完成一半。如果这个操作是一个存储操作，那么其他线程看到的值，可能既不是存储前的值，也不是存储的值。如果非原子操作是一个读取操作，可能先取到对象的一部分，然后值被另一个线程修改，然后它再取到剩余的部分，所以它取到的既不是第一个值，也不是第二个值。这就构成了数据竞争(见5.1节)，出现未定义行为。

### 5.2.1 标准原子类型

标准原子类型定义在头文件 ```<atomic>``` 中。这些类型的操作都是原子的，语言定义中只有这些类型的操作是原子的，也可以用互斥锁来模拟原子操作

它们(几乎)都有一个 ```is_lock_free()```成员函数，这个函数可以让用户查询某原子类型的操作是直接用的原子指令( ```x.is_lock_free()``` 返回 true )，还是内部用了一个锁结构( ```x.is_lock_free()``` 返回 false )。

原子操作可以替代互斥量，来完成同步操作。如果操作内部使用互斥量实现，那么不可能有性能的提升。所以要对原子操作进行实现，最好使用不基于互斥量的实现。

宏都有 ```ATOMIC_BOOL_LOCK_FREE , ATOMIC_CHAR_LOCK_FREE , ATOMIC_CHAR16_T_LOCK_FREE , ATOMIC_CHAR32_T_LOCK_FREE， ATOMIC_WCHAR_T_LOCK_FREE ， ATOMIC_SHORT_LOCK_FREE , ATOMIC_INT_LOCK_FREE , ATOMIC_LONG_LOCK_FREE , ATOMIC_LLONG_LOCK_FREE 和 ATOMIC_POINTER_LOCK_FREE``` 。它们指定了内置原子类型的无锁状态和无符号对应类型(LLONG对应long long，POINTER对应所有指针类型)。如果原子类型**不是无锁结构，那么值为0**。如果原子类型是**无锁结构，那么值为2**。如果原子类型的**无锁状态在运行时才能确定，那么值为1**。

只有 ```std::atomic_flag``` 类型不提供 ```is_lock_free()``` 。该类型是一个简单的布尔标志，并且在这种类型上的操作都是无锁的。

对于 std::atomic<T> 模板，使用相应的T类型去特化模板的方式，要好于使用别名的方式。

通常，标准原子类型不能进行拷贝和赋值，它们没有拷贝构造函数和拷贝赋值操作符。但是，可以隐式转化成对应的内置类型，所以这些类型依旧支持赋值，可以使用 ```load()``` 和 ```store()``` 、 ```exchange()``` 、 ```compare_exchange_weak()``` 和 ```compare_exchange_strong()``` 。

它们都支持复合赋值符：+=, -=, *=, |= 等等。并且使用整型和指针的特化类型还支持++和--操作。当然，这些操作也有功能相同的成员函数所对应：```fetch_add()```, ```fetch_or()```等等。赋值操作和成员函数的返回值，要么是存储值(赋值操作)，要么是操作值(命名函数)，这就能避免赋值操作符返回引用。

```std::atomic<>``` 类模板不仅仅是一套可特化的类型，作为原发模板也可以使用自定义类型创建对应的原子变量。因为是通用类模板，操作限制为 ```load()``` ， ```store()```(赋值和转换为用户类型)，`exchange()` ， `ompare_exchange_weak()` 和 `compare_exchange_strong()` 。

每种函数类型的操作都有一个==内存序参数==，这个参数可以用来指定存储的顺序。5.3节中，会对存储顺序选项进行详述。

现在，只需要知道操作分为三类：

1. Store操作，可选如下内存序： `memory_order_relaxed , memory_order_release , memory_order_seq_cst`
2. Load操作，可选如下内存序：`memory_order_relaxed , memory_order_consume , memory_order_acquire ,memory_order_seq_cst`
3. Read-modify-write(读-改-写)操作，可选如下内存序： `memory_order_relaxed , memory_order_consume ,memory_order_acquire , memory_order_release , memory_order_acq_rel , memory_order_seq_cst`

### 5.2.2 std::atomic_flag

`std::atomic_flag` 是最简单的原子类型，这个类型的对象可以在两个状态间切换：设置和清除。

`std::atomic_flag` 类型的对象必须被ATOMIC_FLAG_INIT初始化。初始化标志位是“清除”状态。这里没得选
择，这个标志总是初始化为“清除”：

```` cpp
std::atomic_flag f = ATOMIC_FLAG_INIT;
````

当标志对象已初始化，只能做三件事情：销毁，清除或设置(查询之前的值)

`clear()`和`test_and_set()`成员函数可以指定好内存顺序。`clear()`是一个存储操作，所以不能有`memory_order_acquire`或`memory_order_acq_rel`语义，但`test_and_set()`是一个“读-改-写”操作，可以应用于任何内存顺序。每一个原子操作，默认的内存序都是`memory_order_seq_cst`。

例如：

```` cpp
f.clear(std::memory_order_release); // 1
bool x=f.test_and_set(); // 2
````

不能拷贝构造 `std::atomic_flag` 对象，不能将一个对象赋予另一个 `std::atomic_flag` 对象。这不是`std::atomic_flag` 特有的属性，而是所有原子类型共有的属性。原子类型的所有操作都是原子的，而赋值和拷贝调用了两个对象，这就就破坏了操作的原子性。这样的话，拷贝构造和拷贝赋值都会将第一个对象的值进行读取，然后再写入另外一个。对于两个独立的对象，这里就有两个独立的操作了，合并这两个操作必定是不原子的。因此，操作就不被允许。

代码5.1 使用 std::atomic_flag 实现自旋锁

```` cpp
class spinlock_mutex
{
  std::atomic_flag flag;
 public:
  spinlock_mutex():
  flag(ATOMIC_FLAG_INIT)
  {}
  void lock()
  {
    while(flag.test_and_set(std::memory_order_acquire));
  }
  void unlock()
  {
    flag.clear(std::memory_order_release);
  }
};
````

### 5.2.3 std::atomic< bool >
