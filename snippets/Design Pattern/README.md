# 设计模式学习笔记（李建忠老师）

## 1. 设计模式简介

&emsp; **什么是设计模式**
&emsp; &emsp; 模式描述了一个**不断重复发生**的问题以及**解决方案核心**

&emsp; **GOF设计模式**

&emsp; &emsp;![GOF设计模式封面](../../src/img/GOF_Design_Pattern.png "GOF设计模式封面" )

<!-- &emsp; &emsp; <img src="../../src/img/GOF_Design_Pattern.png" width="50%" ></img> -->

&emsp; &emsp; 历史性的著作 《设计模式：可复用面向对象软件的基础》
&emsp; &emsp; 关键词：可复用、面向对象（现代设计模式隐含表示面向对象设计模式但不等于）

&emsp; **如何解决复杂性**
&emsp; 自然的想法：
&emsp;&emsp; 1. 分解
&emsp;&emsp; 2. **抽象**：可复用性更强

## 2. 面对对象设计原则

设计模式关心可复用性，**变化**是**复用**的天敌，而面向对象设计的优势在于==抵御变化==，将变化带来的影响降低

对面向对象的认识

1. 对象是拥有某种责任的抽象
2. 各司其职：面向对象强调各个类的“责任”

### 面对对象设计原则

设计模式应依赖、遵守设计原则，设计原则是评判设计模式的标准，违背设计原则的设计模式可以认为是错误的

1. 依赖倒置原则（DIP）
   - 高层模块（稳定）不应该依赖于低层模块（变化），二者都应依赖于抽象（稳定）
   - 抽象（稳定）不应该依赖于实现细节（变化），==实现细节应依赖于抽象（稳定）==
2. 开放封闭原则（OCP）
   - 对拓展开放，对更改封闭
   - 类模块应该设计成是可拓展的，不必修改的（即不需要改代码）
3. 单一职责原则（SRP）
   - 一个类应该仅有一个引起它变化的原因
   - 变化的方向隐含类的责任
4. Liskov（里氏）替换原则（LSP）
   - 子类必须能够替换他们的基类（IS—A关系）
   - 继承表达类型抽象
5. 接口隔离原则（ISP）
   - 接口应该小而完备，
   - 不需要暴露给客户它们不用的方法，否则可能产生依赖关系
6. 优先使用对象组合，而不是类继承
   - 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”
   - 继承破坏了封装性，子类父类天然具有高的耦合性
   - 对象组合只要求被组合的对象具有良好定义的接口即可，耦合度相对较低
7. 封装变化点
   - 使用封装创建对象之间的分界层，让设计者可以在一侧进行修改而不对另一侧产生不良影响，实现层次间的松耦合
8. 针对接口编程，而不是针对实现编程
   - 如不在接口中使用具体业务class，应使用抽象类
   - 实现高内聚，松耦合

设计原则提升

1. 设计习语（Idioms）
  代码级别的底层模式、技巧、惯用法
2. 设计模式（patterns）
  对象直接的组织关系，包括角色、职责、协作方式等
3. 架构模式（Architectural）
  系统中与基本结构组织关系密切的高层模式，包括子系统划分，职责，以及如何组织他们之间关系的规则

## 组件协作模式（模式的分类）

”组件协作“模式包含的典型模型

- Template Method
- Observer / Event
- Strategy

重构到模式（Refactoring to Patterns）

- 好的面向对象设计模式应是满足“应对变化，提高复用”的设计
- 现代软件特征之一是“需求的频繁变化”，设计模式的要点是==寻找变化点，然后在变化点应用设计模式，从而来更好地应对需求的变化==
- ==什么时候、什么地方应用设计模式比理解设计模式的结构本身更重要==
- 倡导从重构到模式（除非特别熟悉业务），没有一步到位的设计模式，在开发过程中不断重构修正设计模式，避免误用设计模式

重构的关键技巧

- 静态 -> 动态
- 继承 -> 组合
- 早绑定 -> 晚绑定
- 编译时依赖 -> 运行时依赖
- 紧耦合 -> 松耦合

### 模板（稳定的样板）方法模式

#### motivation

- 在软件构建过程中，对于某一项任务，它常常有==稳定的整体操作结构==，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。
- 如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？

#### 早绑定与晚绑定

早绑定：后期实现的程序调用较早实现的方法
晚绑定：前期实现的程序调用后期实现的方法（利用虚函数等机制）

#### 模板方法类结构

&emsp; &emsp;![模板方法结构](../../src/img/3_Template_Method_模板方法.png "模板方法结构" )

#### 模板方法总结

- 反向控制结构（晚绑定）
- c++使用虚函数的多态性可以简洁地实现

### 策略模式（Strategy）

#### motivation

- 在软件构建过程中，某些对象使用的算法可能多种多样，**经常改变**，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担
- 如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？

#### 策略模式定义

GoF定义：定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序(稳定)而变化（扩展，子类化）。

#### 策略模式结构

&emsp; &emsp;![策略模式结构](../../src/img/4_策略模式.jpg "策略模式结构" )

#### 策略模式总结

- Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在==运行时==（通过多态）方便地根据需要在各个算法之间进行切换。
- Strategy模式提供了用条件判断语句以外的另一种选择，==消除条件判断语句，就是在解耦合==。含有许多条件判断语句的代码通常都需要Strategy模式。
- *（暂未讲）如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。

### 观察者模式（Observer、Event）

#### motivation

- 在软件构建过程中，我们需要为某些对象建立一种“==通知依赖==关系”  即一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。
- 使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。

#### 观察者模式定义

定义对象间的一种一对多（变化）的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。 ——《设计模式》GoF

#### 观察者模式结构

&emsp; &emsp;![观察者模式结构](../../src/img/5_观察者模式.jpg "观察者模式结构" )

#### 观察者模式总结

- 使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。
- 目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。
- 观察者自己决定是否需要订阅通知，目标对象对此一无所知。
- Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。

## 单一职责模式（模式的分类）

在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。

### 装饰模式 (Decorator)

#### motivation

在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性（编译时已经确定）；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。

如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响将为最低？

#### 装饰模式定义

动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码 & 减少子类个数）。 ——《设计模式》GoF

实现上，decorator继承目标对象同时组合目标对象，即对目标对象进行装饰

&emsp; &emsp;![装饰模式结构](../../src/img/6_装饰模式.jpg "装饰模式结构" )

#### 装饰模式总结

- 通过采用组合而非继承的手法， Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”

- Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。

- Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义。

- 使用继承，使得子类的虚函数继承了父类接口的规范、规格

### 桥模式 (Bridge)

